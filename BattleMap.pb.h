// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BattleMap.proto

#ifndef PROTOBUF_BattleMap_2eproto__INCLUDED
#define PROTOBUF_BattleMap_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace BattleTech_GameBoard {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_BattleMap_2eproto();
void protobuf_AssignDesc_BattleMap_2eproto();
void protobuf_ShutdownFile_BattleMap_2eproto();

class MapHex;
class MapColumn;
class BattleField;

enum MapHex_HexType {
  MapHex_HexType_EMPTY = 0,
  MapHex_HexType_WATER = 1,
  MapHex_HexType_LGTFOREST = 2,
  MapHex_HexType_HVYFOREST = 3,
  MapHex_HexType_ROUGH = 4,
  MapHex_HexType_BUILDING = 5
};
bool MapHex_HexType_IsValid(int value);
const MapHex_HexType MapHex_HexType_HexType_MIN = MapHex_HexType_EMPTY;
const MapHex_HexType MapHex_HexType_HexType_MAX = MapHex_HexType_BUILDING;
const int MapHex_HexType_HexType_ARRAYSIZE = MapHex_HexType_HexType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapHex_HexType_descriptor();
inline const ::std::string& MapHex_HexType_Name(MapHex_HexType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapHex_HexType_descriptor(), value);
}
inline bool MapHex_HexType_Parse(
    const ::std::string& name, MapHex_HexType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapHex_HexType>(
    MapHex_HexType_descriptor(), name, value);
}
enum MapHex_FlipType {
  MapHex_FlipType_NONE = 0,
  MapHex_FlipType_HORIZONTAL = 1,
  MapHex_FlipType_VIRTICAL = 2,
  MapHex_FlipType_HOR_AND_VIR = 3
};
bool MapHex_FlipType_IsValid(int value);
const MapHex_FlipType MapHex_FlipType_FlipType_MIN = MapHex_FlipType_NONE;
const MapHex_FlipType MapHex_FlipType_FlipType_MAX = MapHex_FlipType_HOR_AND_VIR;
const int MapHex_FlipType_FlipType_ARRAYSIZE = MapHex_FlipType_FlipType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapHex_FlipType_descriptor();
inline const ::std::string& MapHex_FlipType_Name(MapHex_FlipType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapHex_FlipType_descriptor(), value);
}
inline bool MapHex_FlipType_Parse(
    const ::std::string& name, MapHex_FlipType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapHex_FlipType>(
    MapHex_FlipType_descriptor(), name, value);
}
// ===================================================================

class MapHex : public ::google::protobuf::Message {
 public:
  MapHex();
  virtual ~MapHex();

  MapHex(const MapHex& from);

  inline MapHex& operator=(const MapHex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapHex& default_instance();

  void Swap(MapHex* other);

  // implements Message ----------------------------------------------

  MapHex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapHex& from);
  void MergeFrom(const MapHex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MapHex_HexType HexType;
  static const HexType EMPTY = MapHex_HexType_EMPTY;
  static const HexType WATER = MapHex_HexType_WATER;
  static const HexType LGTFOREST = MapHex_HexType_LGTFOREST;
  static const HexType HVYFOREST = MapHex_HexType_HVYFOREST;
  static const HexType ROUGH = MapHex_HexType_ROUGH;
  static const HexType BUILDING = MapHex_HexType_BUILDING;
  static inline bool HexType_IsValid(int value) {
    return MapHex_HexType_IsValid(value);
  }
  static const HexType HexType_MIN =
    MapHex_HexType_HexType_MIN;
  static const HexType HexType_MAX =
    MapHex_HexType_HexType_MAX;
  static const int HexType_ARRAYSIZE =
    MapHex_HexType_HexType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HexType_descriptor() {
    return MapHex_HexType_descriptor();
  }
  static inline const ::std::string& HexType_Name(HexType value) {
    return MapHex_HexType_Name(value);
  }
  static inline bool HexType_Parse(const ::std::string& name,
      HexType* value) {
    return MapHex_HexType_Parse(name, value);
  }

  typedef MapHex_FlipType FlipType;
  static const FlipType NONE = MapHex_FlipType_NONE;
  static const FlipType HORIZONTAL = MapHex_FlipType_HORIZONTAL;
  static const FlipType VIRTICAL = MapHex_FlipType_VIRTICAL;
  static const FlipType HOR_AND_VIR = MapHex_FlipType_HOR_AND_VIR;
  static inline bool FlipType_IsValid(int value) {
    return MapHex_FlipType_IsValid(value);
  }
  static const FlipType FlipType_MIN =
    MapHex_FlipType_FlipType_MIN;
  static const FlipType FlipType_MAX =
    MapHex_FlipType_FlipType_MAX;
  static const int FlipType_ARRAYSIZE =
    MapHex_FlipType_FlipType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FlipType_descriptor() {
    return MapHex_FlipType_descriptor();
  }
  static inline const ::std::string& FlipType_Name(FlipType value) {
    return MapHex_FlipType_Name(value);
  }
  static inline bool FlipType_Parse(const ::std::string& name,
      FlipType* value) {
    return MapHex_FlipType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 BaseImage = 1;
  inline bool has_baseimage() const;
  inline void clear_baseimage();
  static const int kBaseImageFieldNumber = 1;
  inline ::google::protobuf::int32 baseimage() const;
  inline void set_baseimage(::google::protobuf::int32 value);

  // optional int32 TerrainDetail = 2;
  inline bool has_terraindetail() const;
  inline void clear_terraindetail();
  static const int kTerrainDetailFieldNumber = 2;
  inline ::google::protobuf::int32 terraindetail() const;
  inline void set_terraindetail(::google::protobuf::int32 value);

  // optional int32 ObjectImage = 3;
  inline bool has_objectimage() const;
  inline void clear_objectimage();
  static const int kObjectImageFieldNumber = 3;
  inline ::google::protobuf::int32 objectimage() const;
  inline void set_objectimage(::google::protobuf::int32 value);

  // optional .BattleTech_GameBoard.MapHex.HexType Terrain = 4 [default = EMPTY];
  inline bool has_terrain() const;
  inline void clear_terrain();
  static const int kTerrainFieldNumber = 4;
  inline ::BattleTech_GameBoard::MapHex_HexType terrain() const;
  inline void set_terrain(::BattleTech_GameBoard::MapHex_HexType value);

  // optional int32 HexElevation = 5;
  inline bool has_hexelevation() const;
  inline void clear_hexelevation();
  static const int kHexElevationFieldNumber = 5;
  inline ::google::protobuf::int32 hexelevation() const;
  inline void set_hexelevation(::google::protobuf::int32 value);

  // optional .BattleTech_GameBoard.MapHex.FlipType TerrainFlip = 6 [default = NONE];
  inline bool has_terrainflip() const;
  inline void clear_terrainflip();
  static const int kTerrainFlipFieldNumber = 6;
  inline ::BattleTech_GameBoard::MapHex_FlipType terrainflip() const;
  inline void set_terrainflip(::BattleTech_GameBoard::MapHex_FlipType value);

  // optional .BattleTech_GameBoard.MapHex.FlipType ObjectFlip = 7 [default = NONE];
  inline bool has_objectflip() const;
  inline void clear_objectflip();
  static const int kObjectFlipFieldNumber = 7;
  inline ::BattleTech_GameBoard::MapHex_FlipType objectflip() const;
  inline void set_objectflip(::BattleTech_GameBoard::MapHex_FlipType value);

  // @@protoc_insertion_point(class_scope:BattleTech_GameBoard.MapHex)
 private:
  inline void set_has_baseimage();
  inline void clear_has_baseimage();
  inline void set_has_terraindetail();
  inline void clear_has_terraindetail();
  inline void set_has_objectimage();
  inline void clear_has_objectimage();
  inline void set_has_terrain();
  inline void clear_has_terrain();
  inline void set_has_hexelevation();
  inline void clear_has_hexelevation();
  inline void set_has_terrainflip();
  inline void clear_has_terrainflip();
  inline void set_has_objectflip();
  inline void clear_has_objectflip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 baseimage_;
  ::google::protobuf::int32 terraindetail_;
  ::google::protobuf::int32 objectimage_;
  int terrain_;
  ::google::protobuf::int32 hexelevation_;
  int terrainflip_;
  int objectflip_;
  friend void  protobuf_AddDesc_BattleMap_2eproto();
  friend void protobuf_AssignDesc_BattleMap_2eproto();
  friend void protobuf_ShutdownFile_BattleMap_2eproto();

  void InitAsDefaultInstance();
  static MapHex* default_instance_;
};
// -------------------------------------------------------------------

class MapColumn : public ::google::protobuf::Message {
 public:
  MapColumn();
  virtual ~MapColumn();

  MapColumn(const MapColumn& from);

  inline MapColumn& operator=(const MapColumn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapColumn& default_instance();

  void Swap(MapColumn* other);

  // implements Message ----------------------------------------------

  MapColumn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapColumn& from);
  void MergeFrom(const MapColumn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .BattleTech_GameBoard.MapHex HexColumn = 1;
  inline int hexcolumn_size() const;
  inline void clear_hexcolumn();
  static const int kHexColumnFieldNumber = 1;
  inline const ::BattleTech_GameBoard::MapHex& hexcolumn(int index) const;
  inline ::BattleTech_GameBoard::MapHex* mutable_hexcolumn(int index);
  inline ::BattleTech_GameBoard::MapHex* add_hexcolumn();
  inline const ::google::protobuf::RepeatedPtrField< ::BattleTech_GameBoard::MapHex >&
      hexcolumn() const;
  inline ::google::protobuf::RepeatedPtrField< ::BattleTech_GameBoard::MapHex >*
      mutable_hexcolumn();

  // optional int32 HexCount = 2;
  inline bool has_hexcount() const;
  inline void clear_hexcount();
  static const int kHexCountFieldNumber = 2;
  inline ::google::protobuf::int32 hexcount() const;
  inline void set_hexcount(::google::protobuf::int32 value);

  // optional bool ColumnIndent = 3;
  inline bool has_columnindent() const;
  inline void clear_columnindent();
  static const int kColumnIndentFieldNumber = 3;
  inline bool columnindent() const;
  inline void set_columnindent(bool value);

  // @@protoc_insertion_point(class_scope:BattleTech_GameBoard.MapColumn)
 private:
  inline void set_has_hexcount();
  inline void clear_has_hexcount();
  inline void set_has_columnindent();
  inline void clear_has_columnindent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::BattleTech_GameBoard::MapHex > hexcolumn_;
  ::google::protobuf::int32 hexcount_;
  bool columnindent_;
  friend void  protobuf_AddDesc_BattleMap_2eproto();
  friend void protobuf_AssignDesc_BattleMap_2eproto();
  friend void protobuf_ShutdownFile_BattleMap_2eproto();

  void InitAsDefaultInstance();
  static MapColumn* default_instance_;
};
// -------------------------------------------------------------------

class BattleField : public ::google::protobuf::Message {
 public:
  BattleField();
  virtual ~BattleField();

  BattleField(const BattleField& from);

  inline BattleField& operator=(const BattleField& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleField& default_instance();

  void Swap(BattleField* other);

  // implements Message ----------------------------------------------

  BattleField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleField& from);
  void MergeFrom(const BattleField& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .BattleTech_GameBoard.MapColumn ColumnList = 1;
  inline int columnlist_size() const;
  inline void clear_columnlist();
  static const int kColumnListFieldNumber = 1;
  inline const ::BattleTech_GameBoard::MapColumn& columnlist(int index) const;
  inline ::BattleTech_GameBoard::MapColumn* mutable_columnlist(int index);
  inline ::BattleTech_GameBoard::MapColumn* add_columnlist();
  inline const ::google::protobuf::RepeatedPtrField< ::BattleTech_GameBoard::MapColumn >&
      columnlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::BattleTech_GameBoard::MapColumn >*
      mutable_columnlist();

  // optional int32 ColumnTotal = 2;
  inline bool has_columntotal() const;
  inline void clear_columntotal();
  static const int kColumnTotalFieldNumber = 2;
  inline ::google::protobuf::int32 columntotal() const;
  inline void set_columntotal(::google::protobuf::int32 value);

  // optional int32 RowTotal = 3;
  inline bool has_rowtotal() const;
  inline void clear_rowtotal();
  static const int kRowTotalFieldNumber = 3;
  inline ::google::protobuf::int32 rowtotal() const;
  inline void set_rowtotal(::google::protobuf::int32 value);

  // optional int32 MapTotal = 4;
  inline bool has_maptotal() const;
  inline void clear_maptotal();
  static const int kMapTotalFieldNumber = 4;
  inline ::google::protobuf::int32 maptotal() const;
  inline void set_maptotal(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BattleTech_GameBoard.BattleField)
 private:
  inline void set_has_columntotal();
  inline void clear_has_columntotal();
  inline void set_has_rowtotal();
  inline void clear_has_rowtotal();
  inline void set_has_maptotal();
  inline void clear_has_maptotal();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::BattleTech_GameBoard::MapColumn > columnlist_;
  ::google::protobuf::int32 columntotal_;
  ::google::protobuf::int32 rowtotal_;
  ::google::protobuf::int32 maptotal_;
  friend void  protobuf_AddDesc_BattleMap_2eproto();
  friend void protobuf_AssignDesc_BattleMap_2eproto();
  friend void protobuf_ShutdownFile_BattleMap_2eproto();

  void InitAsDefaultInstance();
  static BattleField* default_instance_;
};
// ===================================================================


// ===================================================================

// MapHex

// required int32 BaseImage = 1;
inline bool MapHex::has_baseimage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapHex::set_has_baseimage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapHex::clear_has_baseimage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapHex::clear_baseimage() {
  baseimage_ = 0;
  clear_has_baseimage();
}
inline ::google::protobuf::int32 MapHex::baseimage() const {
  // @@protoc_insertion_point(field_get:BattleTech_GameBoard.MapHex.BaseImage)
  return baseimage_;
}
inline void MapHex::set_baseimage(::google::protobuf::int32 value) {
  set_has_baseimage();
  baseimage_ = value;
  // @@protoc_insertion_point(field_set:BattleTech_GameBoard.MapHex.BaseImage)
}

// optional int32 TerrainDetail = 2;
inline bool MapHex::has_terraindetail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapHex::set_has_terraindetail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapHex::clear_has_terraindetail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapHex::clear_terraindetail() {
  terraindetail_ = 0;
  clear_has_terraindetail();
}
inline ::google::protobuf::int32 MapHex::terraindetail() const {
  // @@protoc_insertion_point(field_get:BattleTech_GameBoard.MapHex.TerrainDetail)
  return terraindetail_;
}
inline void MapHex::set_terraindetail(::google::protobuf::int32 value) {
  set_has_terraindetail();
  terraindetail_ = value;
  // @@protoc_insertion_point(field_set:BattleTech_GameBoard.MapHex.TerrainDetail)
}

// optional int32 ObjectImage = 3;
inline bool MapHex::has_objectimage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapHex::set_has_objectimage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapHex::clear_has_objectimage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapHex::clear_objectimage() {
  objectimage_ = 0;
  clear_has_objectimage();
}
inline ::google::protobuf::int32 MapHex::objectimage() const {
  // @@protoc_insertion_point(field_get:BattleTech_GameBoard.MapHex.ObjectImage)
  return objectimage_;
}
inline void MapHex::set_objectimage(::google::protobuf::int32 value) {
  set_has_objectimage();
  objectimage_ = value;
  // @@protoc_insertion_point(field_set:BattleTech_GameBoard.MapHex.ObjectImage)
}

// optional .BattleTech_GameBoard.MapHex.HexType Terrain = 4 [default = EMPTY];
inline bool MapHex::has_terrain() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapHex::set_has_terrain() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapHex::clear_has_terrain() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapHex::clear_terrain() {
  terrain_ = 0;
  clear_has_terrain();
}
inline ::BattleTech_GameBoard::MapHex_HexType MapHex::terrain() const {
  // @@protoc_insertion_point(field_get:BattleTech_GameBoard.MapHex.Terrain)
  return static_cast< ::BattleTech_GameBoard::MapHex_HexType >(terrain_);
}
inline void MapHex::set_terrain(::BattleTech_GameBoard::MapHex_HexType value) {
  assert(::BattleTech_GameBoard::MapHex_HexType_IsValid(value));
  set_has_terrain();
  terrain_ = value;
  // @@protoc_insertion_point(field_set:BattleTech_GameBoard.MapHex.Terrain)
}

// optional int32 HexElevation = 5;
inline bool MapHex::has_hexelevation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapHex::set_has_hexelevation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapHex::clear_has_hexelevation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapHex::clear_hexelevation() {
  hexelevation_ = 0;
  clear_has_hexelevation();
}
inline ::google::protobuf::int32 MapHex::hexelevation() const {
  // @@protoc_insertion_point(field_get:BattleTech_GameBoard.MapHex.HexElevation)
  return hexelevation_;
}
inline void MapHex::set_hexelevation(::google::protobuf::int32 value) {
  set_has_hexelevation();
  hexelevation_ = value;
  // @@protoc_insertion_point(field_set:BattleTech_GameBoard.MapHex.HexElevation)
}

// optional .BattleTech_GameBoard.MapHex.FlipType TerrainFlip = 6 [default = NONE];
inline bool MapHex::has_terrainflip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapHex::set_has_terrainflip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapHex::clear_has_terrainflip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MapHex::clear_terrainflip() {
  terrainflip_ = 0;
  clear_has_terrainflip();
}
inline ::BattleTech_GameBoard::MapHex_FlipType MapHex::terrainflip() const {
  // @@protoc_insertion_point(field_get:BattleTech_GameBoard.MapHex.TerrainFlip)
  return static_cast< ::BattleTech_GameBoard::MapHex_FlipType >(terrainflip_);
}
inline void MapHex::set_terrainflip(::BattleTech_GameBoard::MapHex_FlipType value) {
  assert(::BattleTech_GameBoard::MapHex_FlipType_IsValid(value));
  set_has_terrainflip();
  terrainflip_ = value;
  // @@protoc_insertion_point(field_set:BattleTech_GameBoard.MapHex.TerrainFlip)
}

// optional .BattleTech_GameBoard.MapHex.FlipType ObjectFlip = 7 [default = NONE];
inline bool MapHex::has_objectflip() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MapHex::set_has_objectflip() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MapHex::clear_has_objectflip() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MapHex::clear_objectflip() {
  objectflip_ = 0;
  clear_has_objectflip();
}
inline ::BattleTech_GameBoard::MapHex_FlipType MapHex::objectflip() const {
  // @@protoc_insertion_point(field_get:BattleTech_GameBoard.MapHex.ObjectFlip)
  return static_cast< ::BattleTech_GameBoard::MapHex_FlipType >(objectflip_);
}
inline void MapHex::set_objectflip(::BattleTech_GameBoard::MapHex_FlipType value) {
  assert(::BattleTech_GameBoard::MapHex_FlipType_IsValid(value));
  set_has_objectflip();
  objectflip_ = value;
  // @@protoc_insertion_point(field_set:BattleTech_GameBoard.MapHex.ObjectFlip)
}

// -------------------------------------------------------------------

// MapColumn

// repeated .BattleTech_GameBoard.MapHex HexColumn = 1;
inline int MapColumn::hexcolumn_size() const {
  return hexcolumn_.size();
}
inline void MapColumn::clear_hexcolumn() {
  hexcolumn_.Clear();
}
inline const ::BattleTech_GameBoard::MapHex& MapColumn::hexcolumn(int index) const {
  // @@protoc_insertion_point(field_get:BattleTech_GameBoard.MapColumn.HexColumn)
  return hexcolumn_.Get(index);
}
inline ::BattleTech_GameBoard::MapHex* MapColumn::mutable_hexcolumn(int index) {
  // @@protoc_insertion_point(field_mutable:BattleTech_GameBoard.MapColumn.HexColumn)
  return hexcolumn_.Mutable(index);
}
inline ::BattleTech_GameBoard::MapHex* MapColumn::add_hexcolumn() {
  // @@protoc_insertion_point(field_add:BattleTech_GameBoard.MapColumn.HexColumn)
  return hexcolumn_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BattleTech_GameBoard::MapHex >&
MapColumn::hexcolumn() const {
  // @@protoc_insertion_point(field_list:BattleTech_GameBoard.MapColumn.HexColumn)
  return hexcolumn_;
}
inline ::google::protobuf::RepeatedPtrField< ::BattleTech_GameBoard::MapHex >*
MapColumn::mutable_hexcolumn() {
  // @@protoc_insertion_point(field_mutable_list:BattleTech_GameBoard.MapColumn.HexColumn)
  return &hexcolumn_;
}

// optional int32 HexCount = 2;
inline bool MapColumn::has_hexcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapColumn::set_has_hexcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapColumn::clear_has_hexcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapColumn::clear_hexcount() {
  hexcount_ = 0;
  clear_has_hexcount();
}
inline ::google::protobuf::int32 MapColumn::hexcount() const {
  // @@protoc_insertion_point(field_get:BattleTech_GameBoard.MapColumn.HexCount)
  return hexcount_;
}
inline void MapColumn::set_hexcount(::google::protobuf::int32 value) {
  set_has_hexcount();
  hexcount_ = value;
  // @@protoc_insertion_point(field_set:BattleTech_GameBoard.MapColumn.HexCount)
}

// optional bool ColumnIndent = 3;
inline bool MapColumn::has_columnindent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapColumn::set_has_columnindent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapColumn::clear_has_columnindent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapColumn::clear_columnindent() {
  columnindent_ = false;
  clear_has_columnindent();
}
inline bool MapColumn::columnindent() const {
  // @@protoc_insertion_point(field_get:BattleTech_GameBoard.MapColumn.ColumnIndent)
  return columnindent_;
}
inline void MapColumn::set_columnindent(bool value) {
  set_has_columnindent();
  columnindent_ = value;
  // @@protoc_insertion_point(field_set:BattleTech_GameBoard.MapColumn.ColumnIndent)
}

// -------------------------------------------------------------------

// BattleField

// repeated .BattleTech_GameBoard.MapColumn ColumnList = 1;
inline int BattleField::columnlist_size() const {
  return columnlist_.size();
}
inline void BattleField::clear_columnlist() {
  columnlist_.Clear();
}
inline const ::BattleTech_GameBoard::MapColumn& BattleField::columnlist(int index) const {
  // @@protoc_insertion_point(field_get:BattleTech_GameBoard.BattleField.ColumnList)
  return columnlist_.Get(index);
}
inline ::BattleTech_GameBoard::MapColumn* BattleField::mutable_columnlist(int index) {
  // @@protoc_insertion_point(field_mutable:BattleTech_GameBoard.BattleField.ColumnList)
  return columnlist_.Mutable(index);
}
inline ::BattleTech_GameBoard::MapColumn* BattleField::add_columnlist() {
  // @@protoc_insertion_point(field_add:BattleTech_GameBoard.BattleField.ColumnList)
  return columnlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BattleTech_GameBoard::MapColumn >&
BattleField::columnlist() const {
  // @@protoc_insertion_point(field_list:BattleTech_GameBoard.BattleField.ColumnList)
  return columnlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::BattleTech_GameBoard::MapColumn >*
BattleField::mutable_columnlist() {
  // @@protoc_insertion_point(field_mutable_list:BattleTech_GameBoard.BattleField.ColumnList)
  return &columnlist_;
}

// optional int32 ColumnTotal = 2;
inline bool BattleField::has_columntotal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleField::set_has_columntotal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleField::clear_has_columntotal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleField::clear_columntotal() {
  columntotal_ = 0;
  clear_has_columntotal();
}
inline ::google::protobuf::int32 BattleField::columntotal() const {
  // @@protoc_insertion_point(field_get:BattleTech_GameBoard.BattleField.ColumnTotal)
  return columntotal_;
}
inline void BattleField::set_columntotal(::google::protobuf::int32 value) {
  set_has_columntotal();
  columntotal_ = value;
  // @@protoc_insertion_point(field_set:BattleTech_GameBoard.BattleField.ColumnTotal)
}

// optional int32 RowTotal = 3;
inline bool BattleField::has_rowtotal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleField::set_has_rowtotal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleField::clear_has_rowtotal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleField::clear_rowtotal() {
  rowtotal_ = 0;
  clear_has_rowtotal();
}
inline ::google::protobuf::int32 BattleField::rowtotal() const {
  // @@protoc_insertion_point(field_get:BattleTech_GameBoard.BattleField.RowTotal)
  return rowtotal_;
}
inline void BattleField::set_rowtotal(::google::protobuf::int32 value) {
  set_has_rowtotal();
  rowtotal_ = value;
  // @@protoc_insertion_point(field_set:BattleTech_GameBoard.BattleField.RowTotal)
}

// optional int32 MapTotal = 4;
inline bool BattleField::has_maptotal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleField::set_has_maptotal() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleField::clear_has_maptotal() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleField::clear_maptotal() {
  maptotal_ = 0;
  clear_has_maptotal();
}
inline ::google::protobuf::int32 BattleField::maptotal() const {
  // @@protoc_insertion_point(field_get:BattleTech_GameBoard.BattleField.MapTotal)
  return maptotal_;
}
inline void BattleField::set_maptotal(::google::protobuf::int32 value) {
  set_has_maptotal();
  maptotal_ = value;
  // @@protoc_insertion_point(field_set:BattleTech_GameBoard.BattleField.MapTotal)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace BattleTech_GameBoard

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::BattleTech_GameBoard::MapHex_HexType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BattleTech_GameBoard::MapHex_HexType>() {
  return ::BattleTech_GameBoard::MapHex_HexType_descriptor();
}
template <> struct is_proto_enum< ::BattleTech_GameBoard::MapHex_FlipType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BattleTech_GameBoard::MapHex_FlipType>() {
  return ::BattleTech_GameBoard::MapHex_FlipType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_BattleMap_2eproto__INCLUDED
